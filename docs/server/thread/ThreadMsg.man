.TH initServer thread 2025-06-19 "thread manpages"

.SH NAME
initServer
\-
Initialize a thread.

.SH FILES
.RI ( thread.h ", " thread.c)

.SH SYNOPSIS
.nf
.B #include "thread.h"
.P
.BI "struct ThreadMsg* ThreadMsgCreat(); "
.BI "void ThreadMsgFree(struct ThreadMsg** " threadMsg ");"
.BI "int threadMsgSend(struct ThreadMsg* " coms ", char* " msg ", int " len ");"
.BI "int threadMsgRecv(struct ThreadMsg* " coms ", char** " buf ");"
.fi

.SH DESCRIPTION
ThreadMsg is basically a thread-safe message queue with notifications feature. threadMsgRecv listens
.IR coms 
every few seconds unless there is a notification in which case it checks immediately. Then it sets
.IR buf
to the message. buf is a new pointer each time, free it.

.SH NOTES
This might be the most intuitive thing I ever wrote.

.SH EXAMPLE
This program has a seperate thread printing every message you write along with thread id and what time it got the message. Try with input/output redirection like './main < main.c' to test speed. 

.EX
#include <stdio.h>
#include <string.h>
#include "server.h"
#include <wait.h>

void* printMessages(void* coms) {
	// Free everything when thread exits.
	int oldtype;
	pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype); 

	// print each message. end thread if "exit"
	char* buf = NULL;
	int len = 0;
	while( (len = threadMsgRecv(coms, &buf)) > 0) {
		//sleep(2);
		if(strncmp(buf, "exit", len) == 0) {
			break;
		}
		printf("Thread %lu recieved : %s at %ld\n", pthread_self(), buf, time(NULL));
		free(buf);
		buf = NULL;
	}
	free(buf);
	pthread_exit(NULL);
}

int main() {
	struct ThreadMsg* coms = ThreadMsgCreat();
	pthread_t tid;
	pthread_create(&tid, NULL, printMessages, coms);

	// get bunch of inputs
	char buf[255];
	while(fgets(buf, 255, stdin)) {
	 	threadMsgSend(coms, buf, 0); // 0 makes it use strnlen automatically.
		if(strncmp(buf, "exit", 255) == 0) {
			break;
		}
		printf("Thread %lu sending : %s at %ld\n", pthread_self(), buf, time(NULL));
	}

	pthread_cancel(tid);
	pthread_join(tid, NULL);
	return 0;
}
